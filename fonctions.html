

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fr" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fr" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4.4. Fonctions &mdash; Documentation CoursPythonCPGE </title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/translations.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Recherche" href="search.html" />
    <link rel="next" title="5. Un peu de théorie" href="theorie.html" />
    <link rel="prev" title="4.3. Boucles" href="boucles.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> CoursPythonCPGE
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="io.html">1. Entrée/sortie</a></li>
<li class="toctree-l1"><a class="reference internal" href="types_operateurs_variables.html">2. Types, opérateurs et variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="types_composes.html">3. Types composés</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="algorithmique.html">4. Rudiments d’algorithmique</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="indentation.html">4.1. Indentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tests.html">4.2. Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="boucles.html">4.3. Boucles</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.4. Fonctions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="theorie.html">5. Un peu de théorie</a></li>
<li class="toctree-l1"><a class="reference internal" href="recursivite.html">6. Récursivité</a></li>
<li class="toctree-l1"><a class="reference internal" href="algoclassiques.html">7. Algorithmes classiques</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CoursPythonCPGE</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="algorithmique.html">4. Rudiments d’algorithmique</a> &raquo;</li>
        
      <li>4.4. Fonctions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/fonctions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fonctions">
<h1>4.4. Fonctions<a class="headerlink" href="#fonctions" title="Lien permanent vers ce titre">¶</a></h1>
<p>Une fonction est un bloc d’instructions que l’on peut appeler à tout moment d’un programme. Les fonctions ont plusieurs intérêts, notamment :</p>
<blockquote>
<div><ul class="simple">
<li><p>la réutilisation du code : éviter de répéter les mêmes séries d’instructions à plusieurs endroits d’un programme ;</p></li>
<li><p>la modularité : découper une tâche complexe en plusieurs sous-tâches plus simples.</p></li>
</ul>
</div></blockquote>
<div class="section" id="definir-une-fonction">
<h2>4.4.1. Définir une fonction<a class="headerlink" href="#definir-une-fonction" title="Lien permanent vers ce titre">¶</a></h2>
<p>Au cours des chapitres précédents, on a déjà rencontré de nombreuses fonctions telles que <code class="code docutils literal notranslate"><span class="pre">print</span></code> ou <code class="code docutils literal notranslate"><span class="pre">len</span></code>. Chacune de ces fonctions reçoit un argument et effectue une action (la fonction <code class="code docutils literal notranslate"><span class="pre">print</span></code> affiche un objet à l’écran) ou renvoie une valeur (la fonction <code class="code docutils literal notranslate"><span class="pre">len</span></code> renvoie la taille d’un itérable).</p>
<p>Jusqu’à maintenant, on s’est contenté de faire appel à des fonctions prédéfinies. Mais on peut également définir ses propres fonctions : il faut alors <strong>déclarer</strong> ces fonctions avant de les utiliser. De manière générale, la syntaxe d’une déclaration de fonctions est la suivante.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>def &lt;nom_fonction&gt;(&lt;paramètres&gt;):   # En-tête de la fonction
    &lt;instruction1&gt;
    &lt;instruction2&gt;                  # Corps de la fonction
    ...
    return &lt;valeur&gt;
</pre></div>
</div>
<p>On décrit dans le <em>corps</em> de la fonction les traitements à effectuer sur les paramètres et on spécifie la valeur que doit renvoyer la fonction.</p>
<p>Considérons l’exemple simple suivant.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [1]: </span><span class="k">def</span> <span class="nf">factorielle</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">   ...: </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">   ...: </span>    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">   ...: </span>        <span class="n">a</span> <span class="o">*=</span> <span class="n">k</span>
<span class="gp">   ...: </span>    <span class="k">return</span> <span class="n">a</span>
<span class="gp">   ...: </span>
</pre></div>
</div>
<p>La fonction <code class="code docutils literal notranslate"><span class="pre">factorielle</span></code> prend en argument un objet <code class="code docutils literal notranslate"><span class="pre">n</span></code> (que l’on supposera être un entier naturel), calcule la factorielle de <code class="code docutils literal notranslate"><span class="pre">n</span></code> à l’aide d’une variable <code class="code docutils literal notranslate"><span class="pre">a</span></code> et renvoie cette valeur.</p>
<p>On constate que rien ne se passe lorsque la fonction est déclarée. Il faut <strong>appeler</strong> la fonction en fournissant une valeur à l’entier <code class="code docutils literal notranslate"><span class="pre">n</span></code> pour que le code soit exécuté.</p>
<pre class="literal-block">In [2]: factorielle(5)
Out[2]: 120

In [3]: factorielle(7)
Out[3]: 5040</pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Il faut bien faire la différence entre <strong>la déclaration</strong> et <strong>l’appel</strong> de la fonction. Lorsqu’une fonction est <strong>déclarée</strong>, aucun code n’est exécuté. Il faut <strong>appeler</strong> la fonction pour que le code soit exécuté.</p>
</div>
</div>
<div class="section" id="l-instruction-return">
<h2>4.4.2. L’instruction <code class="code docutils literal notranslate"><span class="pre">return</span></code><a class="headerlink" href="#l-instruction-return" title="Lien permanent vers ce titre">¶</a></h2>
<p>On « sort » de la fonction dès qu’on recontre une instruction <code class="code docutils literal notranslate"><span class="pre">return</span></code> : en particulier, les instructions suivant un <code class="code docutils literal notranslate"><span class="pre">return</span></code> ne sont pas exécutées.</p>
<pre class="literal-block">In [4]: def test(n):
   ...:     if n % 2 == 0:
   ...:         return &quot;n est un multiple de 2&quot;
   ...:     if n % 3 ==0:
   ...:         return &quot;n est un multiple de 3&quot;
   ...:     return &quot;Bidon&quot;
   ...: 

In [5]: test(4)
Out[5]: 'n est un multiple de 2'

In [6]: test(9)
Out[6]: 'n est un multiple de 3'

In [7]: test(6)
Out[7]: 'n est un multiple de 2'

In [8]: test(11)
Out[8]: 'Bidon'</pre>
<p>On peut cependant utiliser ceci à notre avantage : par exemple, pour sortir d’une boucle <code class="code docutils literal notranslate"><span class="pre">for</span></code> avant d’avoir accompli toutes les itérations.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [9]: </span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">floor</span>

<span class="gp">In [10]: </span><span class="k">def</span> <span class="nf">est_premier</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
<span class="gp">   ....: </span>        <span class="k">return</span> <span class="bp">False</span>
<span class="gp">   ....: </span>    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">floor</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">   ....: </span>        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">   ....: </span>            <span class="k">return</span> <span class="bp">False</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="bp">True</span>
<span class="gp">   ....: </span>

<span class="gp">In [11]: </span><span class="k">print</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">est_premier</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
<span class="go">[(0, False), (1, False), (2, True), (3, True), (4, False), (5, True), (6, False), (7, True), (8, False), (9, False)]</span>
</pre></div>
</div>
<p>Une fonction peut ne pas contenir d’instruction <code class="code docutils literal notranslate"><span class="pre">return</span></code> ou peut ne renvoyer aucune valeur. En fait, si on ne renvoie pas explicitement de valeur, Python renverra par défaut la valeur particulière <code class="code docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [12]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [13]: </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [14]: </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">   ....: </span>    <span class="k">return</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [15]: </span><span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">None</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Avertissement</p>
<p>Une erreur de débutant consiste à confondre les utilisations de <code class="code docutils literal notranslate"><span class="pre">print</span></code> et <code class="code docutils literal notranslate"><span class="pre">return</span></code> : une fonction ne comportant qu’un <code class="code docutils literal notranslate"><span class="pre">print</span></code> et pas de <code class="code docutils literal notranslate"><span class="pre">return</span></code> ne fera qu’afficher un résultat à l’écran mais ne renverra aucune valeur.</p>
<pre class="literal-block">In [16]: def bidon():
   ....:     print(1)
   ....:     return 2
   ....: 

In [17]: a = bidon() # La fonction bidon affiche bien 1
1

In [18]: a           # Mais elle a renvoyé la valeur 2
Out[18]: 2</pre>
</div>
<p>La plupart du temps, on préfèrera utiliser utiliser <code class="code docutils literal notranslate"><span class="pre">return</span></code> plutôt que <code class="code docutils literal notranslate"><span class="pre">print</span></code> : l’objet affiché par <code class="code docutils literal notranslate"><span class="pre">print</span></code> est en quelque sorte « perdu » pour le reste du programme s’il n’a pas été renvoyé via <code class="code docutils literal notranslate"><span class="pre">return</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [19]: </span><span class="k">def</span> <span class="nf">liste_carres1</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">([</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [20]: </span><span class="k">def</span> <span class="nf">liste_carres2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<pre class="literal-block"># Avec la première version, la liste des carrés est affichée mais on ne peut plus rien en faire
In [21]: liste_carres1(10)
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# En effet, la fonction renvoie None
In [22]: print(liste_carres1(10))
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
None

# Avec la deuxième version, on peut par exemple calculer la somme des carrés des premiers entiers
In [23]: sum(liste_carres2(10))
Out[23]: 385</pre>
</div>
<div class="section" id="parametres-et-arguments">
<h2>4.4.3. Paramètres et arguments<a class="headerlink" href="#parametres-et-arguments" title="Lien permanent vers ce titre">¶</a></h2>
<p>Une fonction peut avoir zéro, un ou plusieurs paramètres <a class="footnote-reference brackets" href="#zeroparametre" id="id1">1</a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Bien que les termes <em>paramètres</em> et <em>arguments</em> soient souvent confondus, il existe une nuance dont nous tiendrons compte dans ce chapitre : les <em>paramètres</em> sont les noms intervenant dans l’en-tête de la fonction tandis que les <em>arguments</em> sont les valeurs passées à la fonction lors de son appel.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [24]: </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>      <span class="c1"># Les paramètres sont a et b</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">   ....: </span>

<span class="gp">In [25]: </span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>          <span class="c1"># Les arguments sont 5 et 10</span>
<span class="gh">Out[25]: </span><span class="go">15</span>
</pre></div>
</div>
</div>
<p>De même que pour les variables, les noms des paramètres doivent refléter leur utilisation pour que le code soit plus lisible. Par ailleurs, on peut passer des arguments à une fonction en utilisant les noms des paramètres, ce qui rend le code encore plus explicite.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [26]: </span><span class="k">def</span> <span class="nf">nom_complet</span><span class="p">(</span><span class="n">prenom</span><span class="p">,</span> <span class="n">nom</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">prenom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">+</span> <span class="n">prenom</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">nom</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="gp">   ....: </span>

<span class="gp">In [27]: </span><span class="n">nom_complet</span><span class="p">(</span><span class="n">prenom</span><span class="o">=</span><span class="s1">&#39;james&#39;</span><span class="p">,</span> <span class="n">nom</span><span class="o">=</span><span class="s1">&#39;bond&#39;</span><span class="p">)</span>
<span class="gh">Out[27]: </span><span class="go">&#39;James BOND&#39;</span>
</pre></div>
</div>
<p>L’emploi d'<em>arguments nommés</em> permet de passer les arguments dans un ordre différent de l’ordre des paramètres dans l’en-tête de la fonction.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [28]: </span><span class="n">nom_complet</span><span class="p">(</span><span class="n">nom</span><span class="o">=</span><span class="s1">&#39;PrOuSt&#39;</span><span class="p">,</span> <span class="n">prenom</span><span class="o">=</span><span class="s1">&#39;MARcel&#39;</span><span class="p">)</span>
<span class="gh">Out[28]: </span><span class="go">&#39;Marcel PROUST&#39;</span>
</pre></div>
</div>
<p>Il est possible de donner des valeurs par défaut aux paramètres d’une fonction : les arguments correspondants ne sont plus alors requis lors de l’appel de la fonction.</p>
<pre class="literal-block">In [29]: def nom_complet(prenom='Joe', nom='Bob'):
   ....:     return prenom[0].upper() + prenom[1:].lower() + ' ' + nom.upper()
   ....: 

In [30]: nom_complet()
Out[30]: 'Joe BOB'

In [31]: nom_complet('ulysse')
Out[31]: 'Ulysse BOB'

In [32]: nom_complet(nom='capet')
Out[32]: 'Joe CAPET'</pre>
<p>Dans l’en-tête d’une fonction les paramètres avec des valeurs par défaut doivent toujours <em>suivre</em> les paramètres sans valeurs par défaut sous peine de déclencher une erreur de syntaxe.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [33]: </span><span class="k">def</span> <span class="nf">toto</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">pass</span>
<span class="gp">   ....: </span>
<span class="gt">  File</span><span class="nn"> &quot;&lt;ipython-input-33-ff9b54c14016&gt;&quot;</span><span class="gt">, line </span><span class="mi">1</span>
    <span class="k">def</span> <span class="nf">toto</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="o">^</span>
<span class="ne">SyntaxError</span>: non-default argument follows default argument
</pre></div>
</div>
<p>Le but est d’éviter toute ambiguïté. En effet, quels seraient les arguments passés lors de l’appel de fonction <code class="code docutils literal notranslate"><span class="pre">toto(5,</span> <span class="pre">6)</span></code> ? <code class="code docutils literal notranslate"><span class="pre">a=1</span></code>, <code class="code docutils literal notranslate"><span class="pre">b=5</span></code> et <code class="code docutils literal notranslate"><span class="pre">c=6</span></code> ou bien <code class="code docutils literal notranslate"><span class="pre">a=5</span></code>, <code class="code docutils literal notranslate"><span class="pre">b=6</span></code> et <code class="code docutils literal notranslate"><span class="pre">c=2</span></code> ?</p>
</div>
<div class="section" id="portee-des-variables">
<h2>4.4.4. Portée des variables<a class="headerlink" href="#portee-des-variables" title="Lien permanent vers ce titre">¶</a></h2>
<p>Une fonction peut utiliser des variables définies <strong>à l’extérieur</strong> de cette fonction.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [34]: </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>

<span class="gp">In [35]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">   ....: </span>

<span class="gp">In [36]: </span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gh">Out[36]: </span><span class="go">10</span>
</pre></div>
</div>
<p>On dit que les variables définies à l’extérieur d’une fonction sont des variables <strong>globales</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>De manière générale, il est plutôt déconseillé d’utiliser des variables globales à l’intérieur d’une fonction. Il est par exemple plus difficile de tester ou débugger une fonction faisant appel à des variables globales : en plus de chercher les bugs à l’intérieur de la fonction, il faudra examiner tous les endroits où ces variables globales sont potentiellement modifiées, ce qui peut devenir un vrai casse-tête dans un programme complexe.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Avertissement</p>
<p>Si on veut utiliser une variable globale à l’intérieur d’une fonction, il faut que celle-ci soit déclarée <strong>avant</strong> l’appel de cette fonction.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [37]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">b</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">   ....: </span>

<span class="gp">In [38]: </span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gh">Out[38]: </span><span class="go">30</span>

<span class="gp">In [39]: </span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<p>Considérons maintenant l’exemple suivant.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [40]: </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

<span class="gp">In [41]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">   ....: </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="bp">None</span>
<span class="gp">   ....: </span>

<span class="gp">In [42]: </span><span class="n">a</span>
<span class="gh">Out[42]: </span><span class="go">1</span>

<span class="gp">In [43]: </span><span class="n">f</span><span class="p">()</span>

<span class="gp">In [44]: </span><span class="n">a</span>   <span class="c1"># a vaut toujours 1</span>
<span class="gh">Out[44]: </span><span class="go">1</span>
</pre></div>
</div>
<p>On dit que les variables à l’intérieur d’une fonction sont des variables <strong>locales</strong>. Cela signifie en particulier que des opérations effectuées sur une variable d’un certain nom <strong>à l’intérieur</strong> d’une fonction ne modifient pas une variable du même nom <strong>à l’extérieur</strong> de cette fonction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>On évitera cependant de donner des noms identiques à des variables locales et globales de manière à éviter toute confusion.</p>
</div>
<p>Quand il existe des variables locales et globales de même nom, la préférence est donnée aux variables locales à l’intérieur de la fonction.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [45]: </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

<span class="gp">In [46]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x</span>    <span class="c1"># la variable locale a est utilisée et non la variable globale a</span>
<span class="gp">   ....: </span>

<span class="gp">In [47]: </span><span class="n">f</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gh">Out[47]: </span><span class="go">8</span>
</pre></div>
</div>
<p>On ne peut pas accéder à des variables locales à l’extérieur de la fonction où elles sont définies.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [48]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">   ....: </span>    <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="bp">None</span>
<span class="gp">   ....: </span>

<span class="gp">In [49]: </span><span class="n">f</span><span class="p">()</span>

<span class="gp">In [50]: </span><span class="n">c</span>   <span class="c1"># c est inconnu à l&#39;extérieur de la fonction</span>
<span class="gh">Out[50]: </span><span class="go">&#39;t&#39;</span>
</pre></div>
</div>
<p>On peut donc également voir les variables locales comme des variables <em>temporaires</em> dont l’existence n’est assurée qu’à l’intérieur de la fonction où elles interviennent.</p>
<p>On peut néanmoins modifier une variable globale à l’intérieur d’une fonction : on utilise alors le mot-clé <code class="code docutils literal notranslate"><span class="pre">global</span></code>.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [51]: </span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

<span class="gp">In [52]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">   ....: </span>    <span class="k">global</span> <span class="n">a</span>
<span class="gp">   ....: </span>    <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="bp">None</span>
<span class="gp">   ....: </span>

<span class="gp">In [53]: </span><span class="n">a</span>
<span class="gh">Out[53]: </span><span class="go">1</span>

<span class="gp">In [54]: </span><span class="n">f</span><span class="p">()</span>

<span class="gp">In [55]: </span><span class="n">a</span>   <span class="c1"># a vaut bien 2</span>
<span class="gh">Out[55]: </span><span class="go">2</span>
</pre></div>
</div>
<p>Les paramètres d’une fonction ont également une portée locale. On ne peut accéder à une variable locale à l’extérieur de la fonction où elle est définie.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [56]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c</span>
<span class="gp">   ....: </span>

<span class="gp">In [57]: </span><span class="n">c</span>   <span class="c1"># c est inconnu à l&#39;extérieur de la fonction</span>
<span class="gh">Out[57]: </span><span class="go">&#39;t&#39;</span>
</pre></div>
</div>
<p>Enfin, un paramètre ne peut être déclaré comme variable global à l’intérieur d’une fonction.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [58]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
<span class="gp">   ....: </span>     <span class="k">global</span> <span class="n">g</span>
<span class="gp">   ....: </span>
<span class="gt">  File</span><span class="nn"> &quot;&lt;ipython-input-58-c03bf47315f9&gt;&quot;</span><span class="gt">, line </span><span class="mi">5</span>
<span class="ne">SyntaxError</span>: name &#39;g&#39; is parameter and global
</pre></div>
</div>
</div>
<div class="section" id="fonctions-et-mutabilite">
<h2>4.4.5. Fonctions et mutabilité<a class="headerlink" href="#fonctions-et-mutabilite" title="Lien permanent vers ce titre">¶</a></h2>
<p>Considérons ce premier exemple où l’argument est un entier.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [59]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [60]: </span><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>

<span class="gp">In [61]: </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="gp">In [62]: </span><span class="n">a</span>           <span class="c1"># la variable a n&#39;est pas modifiée</span>
<span class="gh">Out[62]: </span><span class="go">2</span>
</pre></div>
</div>
<p>Et maintenant, un deuxième exemple où l’argument est une liste.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [63]: </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">li</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="n">li</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [64]: </span><span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="gp">In [65]: </span><span class="n">g</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

<span class="gp">In [66]: </span><span class="n">lst</span>       <span class="c1"># la variable lst a été modifiée</span>
<span class="gh">Out[66]: </span><span class="go">[1, 2, 3]</span>
</pre></div>
</div>
<p>Le résultat du deuxième exemple peut sembler étrange puisqu’une variable globale a été modifiée à l’intérieur d’une fonction. Pour expliquer cette différence de comportement, il faut comprendre plus en détail comment sont passés les arguments à une fonction et faire une distinction entre les objets <em>mutables</em> et <em>immutables</em>.</p>
<ul class="simple">
<li><p>Lors de l’exécution des instructions <code class="code docutils literal notranslate"><span class="pre">f(a)</span></code> et <code class="code docutils literal notranslate"><span class="pre">g(lst)</span></code>, les emplacements en mémoire dans lesquels sont stockés les objets associés aux variables <code class="code docutils literal notranslate"><span class="pre">a</span></code> et <code class="code docutils literal notranslate"><span class="pre">lst</span></code> (c’est-à-dire l’entier <code class="code docutils literal notranslate"><span class="pre">2</span></code> et la lst <code class="code docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2]</span></code>) sont passés aux fonctions <code class="code docutils literal notranslate"><span class="pre">f</span></code> et <code class="code docutils literal notranslate"><span class="pre">g</span></code> et les paramètres <code class="code docutils literal notranslate"><span class="pre">x</span></code> et <code class="code docutils literal notranslate"><span class="pre">li</span></code> pointent alors vers ces emplacements en mémoire.</p></li>
<li><p>Puisqu’un entier est un objet immutable, l’instruction <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">+=</span> <span class="pre">1</span></code> fait pointer le paramètre <code class="code docutils literal notranslate"><span class="pre">x</span></code> vers un nouvel emplacement mémoire où est stocké l’entier <code class="code docutils literal notranslate"><span class="pre">3</span></code>. Cependant, a variable <code class="code docutils literal notranslate"><span class="pre">a</span></code> pointe toujours vers l’ancien emplacement en mémoire et est donc toujours associée à l’entier <code class="code docutils literal notranslate"><span class="pre">2</span></code>.</p></li>
</ul>
<div class="figure">
<p><img src="_images/tikz-81a98fa821a20ed3a4607555fef05e45a89689f6.png" alt="\node[rectangle,draw,pin={[draw,circle]120:a}](init){2};
\node[rectangle,draw,pin={[draw,circle]90:a},pin={[draw,circle]-90:x}](beginfunc)[right=3cm of init]{2};
\node[rectangle,draw,pin={[draw,circle]90:a}](a endfunc)[right=3cm of beginfunc]{2};
\node[rectangle,draw,pin={[draw,circle]-90:x}](x endfunc)[below=1cm of a endfunc]{3};
\node[rectangle,draw,pin={[draw,circle]60:a}](final)[right=3cm of a endfunc]{2};
\draw[-fast cap,shorten &lt;=10pt,shorten &gt;=10pt,&gt;=latex, blue!20!white, line width=10pt](init) --node[midway,above]{Appel f(a)} (beginfunc);
\draw[-fast cap,shorten &lt;=10pt,shorten &gt;=10pt,&gt;=latex, blue!20!white, line width=10pt](beginfunc) --node[midway,above]{x += 1} (a endfunc);
\draw[-fast cap,shorten &lt;=10pt,shorten &gt;=10pt,&gt;=latex, blue!20!white, line width=10pt](a endfunc) --node[midway,above]{Sortie de f} (final);" /></p>
</div><ul class="simple">
<li><p>Par contre, une liste étant un objet mutable, l’instruction <code class="code docutils literal notranslate"><span class="pre">li.append(3)</span></code> modifie l’objet stocké à l’emplacement en mémoire vers lequel pointe <code class="code docutils literal notranslate"><span class="pre">li</span></code>. Cet objet vaut alors <code class="code docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code>. Mais la variable <code class="code docutils literal notranslate"><span class="pre">lst</span></code> pointe toujours vers le même emplacement en mémoire et est donc associé à cet objet modifié.</p></li>
</ul>
<div class="figure">
<p><img src="_images/tikz-27267dbd617b1660bc6414d7cc6fb29b22c295c2.png" alt="\node[rectangle,draw,pin={[draw,circle]120:lst}](init){[1, 2]};
\node[rectangle,draw,pin={[draw,circle]90:lst},pin={[draw,circle]-90:li}](beginfunc)[right=3cm of init]{[1, 2]};
\node[rectangle,draw,pin={[draw,circle]90:lst},pin={[draw,circle]-90:li}](endfunc)[right=3cm of beginfunc]{[1, 2, 3]};
\node[rectangle,draw,pin={[draw,circle]60:lst}](final)[right=3cm of endfunc]{[1, 2, 3]};
\draw[-fast cap,shorten &lt;=10pt,shorten &gt;=10pt,&gt;=latex, blue!20!white, line width=10pt](init) --node[midway,above]{Appel g(lst)} (beginfunc);
\draw[-fast cap,shorten &lt;=10pt,shorten &gt;=10pt,&gt;=latex, blue!20!white, line width=10pt](beginfunc) --node[midway,above]{li.append(3)} (endfunc);
\draw[-fast cap,shorten &lt;=10pt,shorten &gt;=10pt,&gt;=latex, blue!20!white, line width=10pt](endfunc) --node[midway,above]{Sortie de g} (final);" /></p>
</div><p>On se convaincra plus facilement en utilisant la fonction <code class="code docutils literal notranslate"><span class="pre">id</span></code> qui renvoie l’emplacement où est stocké un objet en mémoire et l’opérateur <code class="code docutils literal notranslate"><span class="pre">is</span></code> qui teste si deux objets sont physiquement égaux (c’est-à-dire s’ils occupent le même emplacement en mémoire).</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [67]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;x début fonction f&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;x fin fonction f&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<pre class="literal-block">In [68]: a = 2

In [69]: print('a avant appel fonction f', id(a))
a avant appel fonction f 140716654813872

In [70]: f(a)
x début fonction f 140716654813872 True
x fin fonction f 140716654813904 False

In [71]: print('a après appel fonction f', id(a))
a après appel fonction f 140716654813872

In [72]: a
Out[72]: 2</pre>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [73]: </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">li</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;li début fonction g&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">li</span><span class="p">),</span> <span class="n">lst</span> <span class="ow">is</span> <span class="n">li</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="n">li</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;toto&#39;</span><span class="p">)</span>
<span class="gp">   ....: </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;li fin fonction g&#39;</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">li</span><span class="p">),</span> <span class="n">lst</span> <span class="ow">is</span> <span class="n">li</span><span class="p">)</span>
<span class="gp">   ....: </span>
</pre></div>
</div>
<pre class="literal-block">In [74]: lst = [1, 2, 3]

In [75]: print('lst avant appel fonction g', id(lst))
lst avant appel fonction g 1744372046920

In [76]: g(lst)
li début fonction g 1744372046920 True
li fin fonction g 1744372046920 True

In [77]: print('lst après appel fonction g', id(lst))
lst après appel fonction g 1744372046920

In [78]: lst
Out[78]: [1, 2, 3, 'toto']</pre>
<p>Finalement, on peut résumer les choses de la manière suivante.</p>
<div class="admonition tip">
<p class="admonition-title">Astuce</p>
<p>Un objet mutable peut-être modifé s’il est passé en argument à une fonction alors que ce ne sera jamais le cas pour un objet immutable.</p>
</div>
<p>Enfin, soulignons qu’il peut se passer des choses étranges lorsque l’on utilise des <em>arguments par défaut mutables</em>.</p>
<pre class="literal-block">In [79]: def pizza(supplements, base=['jambon', 'fromage']):
   ....:     base.extend(supplements)
   ....:     return base
   ....: 

# Jusqu'ici tout va bien
In [80]: print(pizza(['pepperoni', 'poivrons']))
['jambon', 'fromage', 'pepperoni', 'poivrons']

In [81]: print(pizza(['champignons'], ['jambon']))
['jambon', 'champignons']

# Ca devient bizarre
In [82]: print(pizza(['anchois', 'olives']))
['jambon', 'fromage', 'pepperoni', 'poivrons', 'anchois', 'olives']

In [83]: print(pizza(['champignons']))
['jambon', 'fromage', 'pepperoni', 'poivrons', 'anchois', 'olives', 'champignons']

# Ca redevient normal
In [84]: print(pizza(['anchois', 'olives'], ['jambon', 'oeuf', 'fromage']))
['jambon', 'oeuf', 'fromage', 'anchois', 'olives']</pre>
<p>Il faut comprendre que la liste servant d’argument par défaut est créée une fois pour toute <em>à la déclaration de la fonction</em> et non à chaque appel de la fonction. Comme il s’agit d’un objet mutable, chaque appel de la fonction modifie cette liste. A chaque appel de la fonction, c’est donc cette nouvelle liste qui sert d’argument par défaut et non celle définie dans l’en-tête de la fonction.</p>
</div>
<div class="section" id="effets-de-bord">
<h2>4.4.6. Effets de bord<a class="headerlink" href="#effets-de-bord" title="Lien permanent vers ce titre">¶</a></h2>
<p>En plus de renvoyer une valeur, une fonction peut entraîner des modifications au-delà de sa portée comme :</p>
<ul class="simple">
<li><p>modifier des variables globales ;</p></li>
<li><p>modifier des arguments mutables ;</p></li>
<li><p>afficher des informations à l’écran ;</p></li>
<li><p>enregistrer des données dans un fichier.</p></li>
</ul>
<p>On parle alors d'<strong>effet de bord</strong>. Les effets de bord sont à utiliser avec parcimonie : en effet,</p>
</div>
<div class="section" id="une-fonction-est-un-objet">
<h2>4.4.7. Une fonction est un objet<a class="headerlink" href="#une-fonction-est-un-objet" title="Lien permanent vers ce titre">¶</a></h2>
<p>Il est important de noter qu’en Python, les fonctions sont des objets commes les autres (entiers, tuples, …). Notamment, une fonction possède un type.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [85]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">   ....: </span>

<span class="gp">In [86]: </span><span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gh">Out[86]: </span><span class="go">function</span>
</pre></div>
</div>
<p>Ceci est important car on peut par exemple utiliser une fonction comme un argument d’une autre fonction.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [87]: </span><span class="k">def</span> <span class="nf">appliquer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">   ....: </span>

<span class="gp">In [88]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">   ....: </span>

<span class="gp">In [89]: </span><span class="n">appliquer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gh">Out[89]: </span><span class="go">10</span>
</pre></div>
</div>
<p>On peut également créer une fonction qui renvoie une autre fonction.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [90]: </span><span class="k">def</span> <span class="nf">multiplier_par</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">   ....: </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">   ....: </span>        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="n">f</span>
<span class="gp">   ....: </span>

<span class="gp">In [91]: </span><span class="n">multiplier_par</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">5</span><span class="p">)</span>
<span class="gh">Out[91]: </span><span class="go">10</span>
</pre></div>
</div>
</div>
<div class="section" id="fonctions-anonymes">
<h2>4.4.8. Fonctions anonymes<a class="headerlink" href="#fonctions-anonymes" title="Lien permanent vers ce titre">¶</a></h2>
<p>En mathématiques, on peut parler d’une fonction de plusieurs manières.</p>
<blockquote>
<div><ul class="simple">
<li><p>On peut lui donner un nom : on peut par exemple considérer la fonction <span class="math notranslate nohighlight">\(f\)</span> telle que <span class="math notranslate nohighlight">\(f(x)=x^2\)</span>.</p></li>
<li><p>Mais si on ne compte pas réutiliser plus tard cette fonction, on peut tout simplement parler de la fonction <span class="math notranslate nohighlight">\(x\mapsto x^2\)</span>.</p></li>
</ul>
</div></blockquote>
<p>De la même manière, on peut nommer explicitement une fonction.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>On peut également utiliser une <em>fonction anonyme</em> (également appelée <em>fonction lambda</em>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [92]: </span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)(</span><span class="mi">4</span><span class="p">)</span>
<span class="gh">Out[92]: </span><span class="go">16</span>

<span class="gp">In [93]: </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>              <span class="c1"># On peut bien sûr donner un nom à une fonction anonyme</span>

<span class="gp">In [94]: </span><span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="gh">Out[94]: </span><span class="go">16</span>

<span class="gp">In [95]: </span><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span>    <span class="c1"># Une fonction anonyme peut avoir plus d&#39;un argument</span>

<span class="gp">In [96]: </span><span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gh">Out[96]: </span><span class="go">5</span>
</pre></div>
</div>
<p>De manière générale, la syntaxe d’une fonction anonyme est la suivante.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">lambda</span> <span class="o">&lt;</span><span class="n">paramètres</span><span class="o">&gt;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">expression</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>A la différence d’une fonction classique, une fonction anonyme ne nécessite pas d’instruction <code class="code docutils literal notranslate"><span class="pre">return</span></code> : l’expression suivant <code class="code docutils literal notranslate"><span class="pre">:</span></code> est renvoyée <a class="footnote-reference brackets" href="#fctanonyme" id="id2">2</a>.</p>
<p>Les fonctions anonymes sont limitées par rapport aux fonctions classiques : elles ne peuvent pas exécuter plusieurs instructions puisque seule <strong>une</strong> expression est renvoyée. Quel est alors l’intérêt des fonctions anonymes ? Il s’agit de créer des fonctions à usage unique qui peuvent notamment servir d’arguments dans d’autres fonctions.</p>
<p>Par exemple, Python dispose d’une fonction <code class="code docutils literal notranslate"><span class="pre">map</span></code> qui permet d’appliquer une fonction à chaque élément d’un objet de type itérable.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [97]: </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>   <span class="c1"># la fonction map renvoie un objet de type map qu&#39;on convertit en liste</span>
<span class="gh">Out[97]: </span><span class="go">[2, 4, 6]</span>
</pre></div>
</div>
<p>Bien entendu, on arriverait plus aisément au même résultat grâce à une liste en compréhension.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [98]: </span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="gh">Out[98]: </span><span class="go">[2, 4, 6]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<dl class="footnote brackets">
<dt class="label" id="zeroparametre"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Une fonction sans paramètre nécessite quand même des parenthèses dans son en-tête.</p>
<div class="highlight-ipython notranslate"><div class="highlight"><pre><span></span><span class="gp">In [99]: </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">   ....: </span>    <span class="k">return</span> <span class="mi">1</span>
<span class="gp">   ....: </span>

<span class="gp">In [100]: </span><span class="n">f</span><span class="p">()</span>
<span class="gh">Out[100]: </span><span class="go">1</span>
</pre></div>
</div>
</dd>
<dt class="label" id="fctanonyme"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Une fonction anonyme peut également avoir des effets de bord.</p>
<pre class="literal-block">In [101]: f = lambda li: li.append('toto')

In [102]: a = [1, 2]

In [103]: f(a)

In [104]: a               # La fonction anonyme f a modifié la liste a
Out[104]: [1, 2, 'toto']

In [105]: print(f(a))     # Par contre, la fonction ne renvoie rien (en fait, renvoie None)
None</pre>
</dd>
</dl>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">À faire</p>
<p>Documentation d’une fonction</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="theorie.html" class="btn btn-neutral float-right" title="5. Un peu de théorie" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="boucles.html" class="btn btn-neutral float-left" title="4.3. Boucles" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Laurent Garcin

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>